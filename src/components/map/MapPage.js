import GoogleMapReact from 'google-map-react'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useDispatch, useSelector } from 'react-redux'
import { useLocation } from 'react-router-dom'
import styled from 'styled-components/macro'

import { VISIBLE_CLUSTER_ZOOM_LIMIT } from '../../constants/map'
import { fetchFilterCounts } from '../../redux/filterSlice'
import { setFromSettings, updatePosition } from '../../redux/locationSlice'
import { disconnectMap, setGoogle } from '../../redux/mapSlice'
import { fetchLocations } from '../../redux/viewChange'
import { updateLastMapView } from '../../redux/viewportSlice'
import throttle from '../../utils/throttle'
import { useAppHistory } from '../../utils/useAppHistory'
import Share from '../share/Share'
import ShareIconButton from '../share/ShareIconButton'
import { AddLocationMobile } from '../ui/AddLocation'
import LoadingIndicator from '../ui/LoadingIndicator'
import CloseStreetView from './CloseStreetView'
import Cluster from './Cluster'
import { ConnectGeolocation, isGeolocationOpen } from './ConnectGeolocation'
import GeolocationDot from './GeolocationDot'
import Location from './Location'
import PanoramaHandler from './PanoramaHandler'
import {
  AddLocationCentralUnmovablePin,
  DraggableMapPin,
  EditLocationCentralUnmovablePin,
} from './Pins'
import Place from './Place'
import TrackLocationButton from './TrackLocationButton'

const MIN_ZOOM = 1

const BottomLeftLoadingIndicator = styled(LoadingIndicator)`
  position: absolute;
  inset-inline-start: 10px;
  inset-block-end: 10px;
`

const ZoomButton = styled.button`
  position: absolute;
  inset-inline-start: 10px;
  width: 40px;
  height: 40px;
  background-color: white;
  color: ${({ theme }) => theme.headerText};
  ${({ isDesktop }) =>
    isDesktop &&
    `
    &:hover {
      background-color: #f0f0f0;
    }
  `}
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: ${(props) => (props.disabled ? 'not-allowed' : 'pointer')};
  opacity: ${(props) => (props.disabled ? 0.5 : 1)};
  z-index: 1;
`

const StyledIconButton = styled(ShareIconButton)`
  background-color: white;
  border-radius: 4px;
  border: 1px solid #ccc;
  ${({ isDesktop }) =>
    isDesktop &&
    `
    &:hover {
      background-color: #f0f0f0;
    }
  `}
  svg {
    color: black;
  }
`

const ZoomInButton = styled(ZoomButton)`
  inset-block-start: calc(50% - 45px);
`

const ZoomOutButton = styled(ZoomButton)`
  inset-block-start: calc(50% + 5px);
`

const ShareContainer = styled.div`
  position: absolute;
  inset-block-start: 10px;
  inset-inline-end: 10px;
  background-color: white;
  border-radius: 4px;
  padding: 10px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  z-index: 1;
  width: 300px;
`

const EARTH_RADIUS = 6378137 // meters
const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS // meters
//AI generated by giving it https://github.com/falling-fruit/falling-fruit-api/blob/main/helpers.js
const clusterBounds = ({ lat, lng, zoom }) => {
  // Convert WGS84 to Web Mercator
  const mercator = {
    x: (lng / 360) * EARTH_CIRCUMFERENCE,
    y: Math.log(Math.tan((lat + 90) * (Math.PI / 360))) * EARTH_RADIUS,
  }

  // Convert Web Mercator to grid cell indices
  const cell_size = EARTH_CIRCUMFERENCE / 2 ** zoom
  const cell = {
    x: Math.floor((mercator.x + EARTH_CIRCUMFERENCE / 2) / cell_size),
    y: Math.floor((mercator.y + EARTH_CIRCUMFERENCE / 2) / cell_size),
  }

  // Convert grid cell indices to Web Mercator bounds
  // (cell.x, cell.y) is the bottom-left (south-west) corner of the cell
  const bounds = {
    south: cell.y * cell_size - EARTH_CIRCUMFERENCE / 2,
    west: cell.x * cell_size - EARTH_CIRCUMFERENCE / 2,
    north: (cell.y + 1) * cell_size - EARTH_CIRCUMFERENCE / 2,
    east: (cell.x + 1) * cell_size - EARTH_CIRCUMFERENCE / 2,
  }

  // Convert Web Mercator bounds to WGS84
  return {
    south:
      90 -
      (Math.atan2(1, Math.exp(bounds.south / EARTH_RADIUS)) * 360) / Math.PI,
    west: bounds.west * (360 / EARTH_CIRCUMFERENCE),
    north:
      90 -
      (Math.atan2(1, Math.exp(bounds.north / EARTH_RADIUS)) * 360) / Math.PI,
    east: bounds.east * (360 / EARTH_CIRCUMFERENCE),
  }
}
const makeHandleViewChange =
  (dispatch, googleMap, history) => (googleMapReactCallbackArg) => {
    const center = googleMap.getCenter()
    const newView = {
      center: { lat: center.lat(), lng: center.lng() },
      zoom: googleMap.getZoom(),
      bounds: googleMap.getBounds().toJSON(),
      width: googleMap.getDiv().offsetWidth,
      height: googleMap.getDiv().offsetHeight,
    }
    dispatch(updateLastMapView(newView))
    dispatch(fetchLocations())
    dispatch(fetchFilterCounts())
    if (googleMapReactCallbackArg) {
      history.changeView(newView)
    }
  }

/**
 * Calculate XYZ tile coordinates.
 *
 * @param {Object} coord - Google Maps world coordinates.
 * @param {number} zoom - Google Maps zoom level.
 * @returns {Object} XYZ tile coordinates. `y` is `null` if out of bounds.
 */
function getTileCoordinates(coord, zoom) {
  // Wrap x (longitude) at 180th meridian properly
  const tilesPerGlobe = 1 << zoom
  let x = coord.x % tilesPerGlobe
  if (x < 0) {
    x = tilesPerGlobe + x
  }
  let y = coord.y
  if (coord.y < 0 || coord.y >= tilesPerGlobe) {
    y = null
  }
  return { x, y, z: zoom }
}

const GoogleMapWrapper = ({ onUnmount, ...props }) => {
  useEffect(() => onUnmount, []) //eslint-disable-line

  return <GoogleMapReact {...props} />
}

const MapPage = ({ isDesktop }) => {
  const { i18n } = useTranslation()
  const isRTL = i18n.dir() === 'rtl'
  const history = useAppHistory()
  const dispatch = useDispatch()
  const handleViewChangeRef = useRef(() => void 0)

  const [draggedPosition, setDraggedPosition] = useState(null)
  const [shareOpen, setShareOpen] = useState(false)

  const {
    initialView,
    locations,
    clusters,
    isLoading: mapIsLoading,
    googleMap,
    getGoogleMaps,
  } = useSelector((state) => state.map)

  const currentZoom = googleMap?.getZoom()

  const place = useSelector((state) => state.place.selectedPlace)

  const { geolocation, geolocationState } = useSelector(
    (state) => state.geolocation,
  )
  const { pathname } = useLocation()
  const {
    locationId,
    position,
    isBeingEdited: isEditingLocation,
    location: selectedLocation,
    isLoading: locationIsLoading,
    streetViewOpen: showStreetView,
    isBeingInitializedMobile,
  } = useSelector((state) => state.location)
  const {
    mapType,
    overlay,
    showLabels: settingsShowLabels,
    showBusinesses,
  } = useSelector((state) => state.settings)

  // Convert overlay setting to mapLayers format expected by the map
  const getLayerType = (overlayType) => {
    if (overlayType === 'bicycle') {
      return 'BicyclingLayer'
    }
    if (overlayType === 'transit') {
      return 'TransitLayer'
    }
    return overlayType
  }

  const layerTypes = overlay ? [getLayerType(overlay)] : []

  const { typesAccess } = useSelector((state) => state.type)

  const apiIsLoaded = (map, maps) => {
    /*
     * Something breaks when storing maps in redux so pass a reference to it
     */
    dispatch(setGoogle({ googleMap: map, getGoogleMaps: () => maps }))
  }

  useEffect(() => {
    const ready = dispatch && !typesAccess.isEmpty && googleMap
    if (ready) {
      /*
       * This usually happens after apiIsLoaded puts googleMap in redux
       * but on first render, types might not have been fetched yet so only install the handler when both happened
       */
      handleViewChangeRef.current = throttle(
        makeHandleViewChange(dispatch, googleMap, history),
        1000,
      )
      /*
       * Call the handler for the first time since map (re)opened
       */
      handleViewChangeRef.current(false)
    }
  }, [!typesAccess.isEmpty, googleMap, !!dispatch]) //eslint-disable-line

  const allLocations =
    clusters.length !== 0
      ? []
      : selectedLocation
        ? [...locations, selectedLocation].filter(
            (loc, index, self) =>
              index === self.findIndex((t) => t.id === loc.id),
          )
        : locations

  const isAddingLocation = locationId === 'new' || isBeingInitializedMobile
  const isViewingLocation =
    locationId !== null && !isEditingLocation && !isAddingLocation
  const showLabels = settingsShowLabels || isAddingLocation || isEditingLocation

  useEffect(() => {
    setDraggedPosition(isDesktop ? position : null)
  }, [position, isDesktop])

  const handleClusterClick = (cluster) => {
    if (cluster.count === 1) {
      googleMap?.panTo({
        lat: cluster.lat,
        lng: cluster.lng,
      })
      googleMap?.setZoom(VISIBLE_CLUSTER_ZOOM_LIMIT + 1)
    } else {
      const bounds = clusterBounds({
        lat: cluster.lat,
        lng: cluster.lng,
        zoom: currentZoom + 1,
      })
      googleMap?.fitBounds(bounds)
    }
  }

  const handleLocationClick = (location) => {
    if (isDesktop && pathname.includes('/settings')) {
      dispatch(setFromSettings(true))
    }
    history.push(`/locations/${location.id}`)
  }

  const handleNonspecificClick = ({ event }) => {
    event.stopPropagation()
    if (isViewingLocation) {
      history.push('/map')
    }
  }

  const zoomIn = () => {
    googleMap?.setZoom(currentZoom + 1)
  }
  const zoomOut = () => {
    googleMap?.setZoom(currentZoom - 1)
  }

  const toggleShare = useCallback(() => {
    setShareOpen((prev) => !prev)
  }, [])
  return (
    <>
      {(mapIsLoading || locationIsLoading) && <BottomLeftLoadingIndicator />}
      {isAddingLocation && !isDesktop && <AddLocationCentralUnmovablePin />}
      {!isAddingLocation && !isEditingLocation && !isDesktop && (
        <AddLocationMobile />
      )}
      {isEditingLocation && !isDesktop && <EditLocationCentralUnmovablePin />}
      {!isDesktop && <TrackLocationButton isIcon />}

      <ZoomInButton
        onClick={zoomIn}
        disabled={
          !currentZoom || currentZoom >= (mapType === 'roadmap' ? 22 : 21)
        }
        isDesktop={isDesktop}
      >
        +
      </ZoomInButton>
      <ZoomOutButton
        onClick={zoomOut}
        disabled={!currentZoom || currentZoom <= MIN_ZOOM}
        isDesktop={isDesktop}
      >
        -
      </ZoomOutButton>

      {isDesktop && (
        <>
          {shareOpen ? (
            <ShareContainer>
              <Share onClose={() => setShareOpen(false)} />
            </ShareContainer>
          ) : (
            <div
              style={{
                position: 'absolute',
                insetBlockStart: '10px',
                insetInlineEnd: '10px',
                zIndex: 1,
              }}
            >
              <StyledIconButton size={40} onClick={toggleShare} />
            </div>
          )}
        </>
      )}

      {isGeolocationOpen(geolocationState) && <ConnectGeolocation />}

      {googleMap && <PanoramaHandler />}
      {showStreetView && <CloseStreetView />}
      {initialView && (
        <GoogleMapWrapper
          onClick={handleNonspecificClick}
          bootstrapURLKeys={{
            apiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY,
            version: 'quarterly',
            libraries: ['places'],
            language: i18n.language,
          }}
          options={(googleMaps) => ({
            mapTypeId: mapType,
            disableDefaultUI: true,
            rotateControlOptions: {
              position: isRTL
                ? googleMaps.ControlPosition.RIGHT_BOTTOM
                : googleMaps.ControlPosition.LEFT_BOTTOM,
            },
            minZoom: MIN_ZOOM,
            // Toggle all basemap icons
            // https://developers.google.com/maps/documentation/javascript/style-reference
            styles: [
              {
                featureType: 'poi',
                elementType: 'labels.icon',
                stylers: [{ visibility: showBusinesses ? 'on' : 'off' }],
              },
              {
                featureType: 'landscape',
                elementType: 'labels.icon',
                stylers: [{ visibility: showBusinesses ? 'on' : 'off' }],
              },
            ],
          })}
          layerTypes={layerTypes}
          defaultCenter={initialView.center}
          defaultZoom={initialView.zoom}
          onChange={handleViewChangeRef.current}
          onGoogleApiLoaded={({ map, maps }) => {
            map.mapTypes.set(
              'osm-standard',
              new maps.ImageMapType({
                getTileUrl: (coord, zoom) => {
                  const { x, y, z } = getTileCoordinates(coord, zoom)
                  if (y !== null) {
                    return `https://tile.openstreetmap.org/${z}/${x}/${y}.png`
                  }
                },
                tileSize: new maps.Size(256, 256),
                maxZoom: 19,
              }),
            )
            map.mapTypes.set(
              'osm-toner-lite',
              new maps.ImageMapType({
                getTileUrl: (coord, zoom) => {
                  const { x, y, z } = getTileCoordinates(coord, zoom)
                  if (y !== null) {
                    return `https://tiles.stadiamaps.com/tiles/stamen_toner-lite/${z}/${x}/${y}.png`
                  }
                },
                tileSize: new maps.Size(256, 256),
                maxZoom: 20,
              }),
            )
            apiIsLoaded(map, maps)
          }}
          yesIWantToUseGoogleMapApiInternals
          onUnmount={() => {
            dispatch(disconnectMap())
          }}
        >
          {geolocation && !geolocation.loading && !geolocation.error && (
            <GeolocationDot
              lat={geolocation.latitude}
              lng={geolocation.longitude}
            />
          )}
          {place &&
            place.location &&
            place.view &&
            place.view.zoom >= VISIBLE_CLUSTER_ZOOM_LIMIT &&
            currentZoom >= VISIBLE_CLUSTER_ZOOM_LIMIT && (
              <Place
                lat={place.location.lat}
                lng={place.location.lng}
                label={place.location.description}
              />
            )}
          {clusters.map((cluster) => (
            <Cluster
              key={JSON.stringify(cluster)}
              onClick={(event) => {
                handleClusterClick(cluster)
                event.stopPropagation()
              }}
              count={cluster.count}
              lat={cluster.lat}
              lng={cluster.lng}
            />
          ))}
          {allLocations.map((location) => (
            <Location
              key={location.id}
              onClick={
                isEditingLocation || isAddingLocation
                  ? null
                  : (event) => {
                      handleLocationClick(location)
                      event.stopPropagation()
                    }
              }
              lat={location.lat}
              lng={location.lng}
              selected={location.id === locationId}
              editing={isEditingLocation && location.id === locationId}
              showLabel={showLabels}
              typeIds={location.type_ids}
            />
          ))}
          {(isEditingLocation || isAddingLocation) && draggedPosition && (
            <DraggableMapPin
              lat={draggedPosition.lat}
              lng={draggedPosition.lng}
              // confusingly it doesn't work from inside the component
              $geoService={getGoogleMaps && getGoogleMaps().Geocoder}
              onChange={setDraggedPosition}
              onDragEnd={(newPosition) => {
                dispatch(updatePosition(newPosition))
              }}
            />
          )}
        </GoogleMapWrapper>
      )}
    </>
  )
}

export default MapPage
