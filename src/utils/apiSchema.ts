/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/users.json": {
    post: {
      parameters: {
        query: {
          /** User email. */
          email: string;
          /** User password. */
          password: string;
          /** User name. */
          name?: string;
          /** Whether the user's `name` should be displayed as the author name on locations and reviews added by this user. */
          add_anonymously?: { [key: string]: any };
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": Partial<{
              auth_token: string;
            }> &
              Partial<components["schemas"]["Error"]>;
          };
        };
      };
    };
  };
  "/login.json": {
    get: {
      parameters: {
        query: {
          /** User email. */
          email: string;
          /** User password. */
          password: string;
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": Partial<{
              auth_token: string;
            }> &
              Partial<components["schemas"]["Error"]>;
          };
        };
      };
    };
  };
  "/logout.json": {
    get: {
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": Partial<{ [key: string]: any }> &
              Partial<components["schemas"]["Error"]>;
          };
        };
      };
    };
  };
  "/clusters.json": {
    get: {
      parameters: {
        query: {
          /** Longitude of southwest corner in WGS84 decimal degrees. */
          swlng: components["parameters"]["swlng"];
          /** Longitude of northeast corner in WGS84 decimal degrees. */
          nelng: components["parameters"]["nelng"];
          /** Latitude of southwest corner in WGS84 decimal degrees. */
          swlat: components["parameters"]["swlat"];
          /** Latitude of northeast corner in WGS84 decimal degrees. */
          nelat: components["parameters"]["nelat"];
          /** Zoom level, where the world is divided into a 2<sup>zoom</sup> x 2<sup>zoom</sup> grid. */
          zoom?: components["parameters"]["zoom"];
          /** Whether to include Locations imported from municipal tree inventories. */
          muni?: components["parameters"]["muni"];
          /** IDs of Types to include (or all if empty or missing). */
          t?: components["parameters"]["t"];
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": Partial<components["schemas"]["Cluster"][]> &
              Partial<components["schemas"]["Error"]>;
          };
        };
      };
    };
  };
  "/types/counts.json": {
    get: {
      parameters: {
        query: {
          /** Longitude of southwest corner in WGS84 decimal degrees. Must be used with `nelng`, `swlat`, and `nelat`. If provided, only returns (and counts) the Types of Locations within these bounds. */
          swlng?: number;
          /** Longitude of northeast corner in WGS84 decimal degrees. */
          nelng?: number;
          /** Latitude of southwest corner in WGS84 decimal degrees. */
          swlat?: number;
          /** Latitude of northeast corner in WGS84 decimal degrees. */
          nelat?: number;
          /** Zoom level, where the world is divided into a 2<sup>zoom</sup> x 2<sup>zoom</sup> grid. Used with `swlng`, `nelng`, `swlat`, and `nelat`. If provided, only returns (and counts) the Types of Locations whose Cluster centerpoints at this zoom level fall within the bounds. Otherwise, an exact count is performed using Location coordinates. */
          zoom?: number;
          /** Whether to return (and count) the Types of Locations imported from municipal tree inventories. */
          muni?: 0 | 1;
          /** Type categories to return. */
          c?: components["parameters"]["c"];
          /** Whether to return uncategorized types. */
          uncategorized?: 0 | 1;
          /** Whether to return pending types. */
          pending?: 0 | 1;
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": components["schemas"]["TypeCount"][];
          };
        };
      };
    };
  };
  "/types.json": {
    get: {
      parameters: {
        query: {
          /** Longitude of southwest corner in WGS84 decimal degrees. Must be used with `nelng`, `swlat`, and `nelat`. If provided, only returns (and counts) the Types of Locations within these bounds. */
          swlng?: number;
          /** Longitude of northeast corner in WGS84 decimal degrees. */
          nelng?: number;
          /** Latitude of southwest corner in WGS84 decimal degrees. */
          swlat?: number;
          /** Latitude of northeast corner in WGS84 decimal degrees. */
          nelat?: number;
          /** Zoom level, where the world is divided into a 2<sup>zoom</sup> x 2<sup>zoom</sup> grid. Used with `swlng`, `nelng`, `swlat`, and `nelat`. If provided, only returns (and counts) the Types of Locations whose Cluster centerpoints at this zoom level fall within the bounds. */
          zoom?: number;
          /** Whether to return (and count) the Types of Locations imported from municipal tree inventories. */
          muni?: 0 | 1;
          /** Locale of common name labels to return. */
          locale?: components["parameters"]["locale"];
          /** Whether to return URL properties. */
          urls?: 0 | 1;
          /** Type categories to return. */
          c?: components["parameters"]["c"];
          /** Whether to return uncategorized types. */
          uncategorized?: 0 | 1;
          /** Whether to return pending types. */
          pending?: 0 | 1;
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": components["schemas"]["ListType"][];
          };
        };
      };
    };
  };
  "/types/{id}.json": {
    get: {
      parameters: {
        path: {
          /** Type ID */
          id: number;
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": components["schemas"]["SingleType"];
          };
        };
      };
    };
  };
  "/locations.json": {
    get: {
      parameters: {
        query: {
          /** Longitude of southwest corner in WGS84 decimal degrees. */
          swlng: components["parameters"]["swlng"];
          /** Longitude of northeast corner in WGS84 decimal degrees. */
          nelng: components["parameters"]["nelng"];
          /** Latitude of southwest corner in WGS84 decimal degrees. */
          swlat: components["parameters"]["swlat"];
          /** Latitude of northeast corner in WGS84 decimal degrees. */
          nelat: components["parameters"]["nelat"];
          /** Whether to include Locations imported from municipal tree inventories. */
          muni?: components["parameters"]["muni"];
          /** Type categories to return. */
          c?: components["parameters"]["c"];
          /** IDs of Types to include (or all if empty or missing). */
          t?: components["parameters"]["t"];
          /** Locale of common name labels to return. */
          locale?: components["parameters"]["locale"];
          /**
           * Whether to return Types flagged as invasive species.
           * - 0: Hides invasive species.
           * - 1: Only returns invasive species.
           */
          invasive?: 0 | 1;
          /** Maximum number of Locations to return. */
          limit?: number;
          /** Offset from which to apply `limit`. */
          offset?: number;
          /** Whether to return first Review photo (if available). */
          reviews?: 0 | 1;
          /** Longitude in WGS84 decimal degrees. Must be used with `lat`. If provided, the distance to each Location is returned. */
          lng?: number;
          /** Latitude in WGS84 decimal degrees. */
          lat?: number;
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": (
              | number
              | number
              | components["schemas"]["ListLocation"]
            )[];
          };
        };
      };
    };
    post: {
      parameters: {
        query: {
          /** Longitude in WGS84 decimal degrees. */
          lng: components["parameters"]["lng"];
          /** Latitude in WGS84 decimal degrees. */
          lat: components["parameters"]["lat"];
          /** Type IDs. */
          type_ids: components["parameters"]["type_ids"];
          /** Author name. If not provided, defaults to the User's name if the user has not opted to add locations anonymously. */
          author?: components["parameters"]["author"];
          /** Description. */
          description?: components["parameters"]["description"];
          /** First month in season (zero-based). */
          season_start?: components["parameters"]["season_start"];
          /** Last month in season (zero-based). */
          season_stop?: components["parameters"]["season_stop"];
          /** Whether always in season (e.g. rosemary). Equivalent to `season_start=0` (January) and `season_stop=11` (December). */
          no_season?: components["parameters"]["no_season"];
          /** Whether needs verification. */
          unverified?: components["parameters"]["unverified"];
          /**
           * Access level.
           * - 0: Location is on my property.
           * - 1: I have permission from the owner to add this Location.
           * - 2: Location is on public land.
           * - 3: Location is on private property but overhangs public property.
           * - 4: Location is on private property.
           */
          access?: components["parameters"]["access"];
          /** Review comment. */
          comment?: components["parameters"]["comment"];
          /**
           * Fruiting status.
           * - 0: Flowers.
           * - 1: Unripe fruit.
           * - 2: Ripe fruit.
           */
          fruiting?: components["parameters"]["fruiting"];
          /**
           * Quality rating.
           * - 0: Poor.
           * - 1: Fair.
           * - 2: Good.
           * - 3: Very good.
           * - 4: Excellent.
           */
          quality_rating?: components["parameters"]["quality_rating"];
          /**
           * Yield rating.
           * - 0: Poor.
           * - 1: Fair.
           * - 2: Good.
           * - 3: Very good.
           * - 4: Excellent.
           */
          yield_rating?: components["parameters"]["yield_rating"];
          /** Date visited in format YYYY-MM-DD. */
          observed_on?: components["parameters"]["observed_on"];
          /** Photo file basename. */
          photo_file_name?: components["parameters"]["photo_file_name"];
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": {
              /** ID of new Location. */
              location_id: number;
              /** ID of new Review. */
              observation_id?: number;
              images?: components["schemas"]["PhotoPaths"];
            };
          };
        };
      };
      requestBody: {
        content: {
          "multipart/form-data": {
            photo_data?: string;
          };
        };
      };
    };
  };
  "/locations/{id}.json": {
    get: {
      parameters: {
        path: {
          /** Location ID. */
          id: components["parameters"]["location_id"];
        };
        query: {
          /** Locale of common name labels to return. */
          locale?: components["parameters"]["locale"];
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": components["schemas"]["SingleLocation"];
          };
        };
      };
    };
    post: {
      parameters: {
        path: {
          /** Location ID. */
          id: components["parameters"]["location_id"];
        };
        query: {
          /** Longitude in WGS84 decimal degrees. */
          lng: components["parameters"]["lng"];
          /** Latitude in WGS84 decimal degrees. */
          lat: components["parameters"]["lat"];
          /** Type IDs. */
          type_ids: components["parameters"]["type_ids"];
          /** Author name. If not provided, defaults to the User's name if the user has not opted to add locations anonymously. */
          author?: components["parameters"]["author"];
          /** Description. */
          description?: components["parameters"]["description"];
          /** First month in season (zero-based). */
          season_start?: components["parameters"]["season_start"];
          /** Last month in season (zero-based). */
          season_stop?: components["parameters"]["season_stop"];
          /** Whether always in season (e.g. rosemary). Equivalent to `season_start=0` (January) and `season_stop=11` (December). */
          no_season?: components["parameters"]["no_season"];
          /** Whether needs verification. */
          unverified?: components["parameters"]["unverified"];
          /**
           * Access level.
           * - 0: Location is on my property.
           * - 1: I have permission from the owner to add this Location.
           * - 2: Location is on public land.
           * - 3: Location is on private property but overhangs public property.
           * - 4: Location is on private property.
           */
          access?: components["parameters"]["access"];
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": {
              /** ID of new Location. */
              location_id: number;
            };
          };
        };
      };
    };
  };
  "/locations/{id}/reviews.json": {
    get: {
      parameters: {
        path: {
          /** Location ID. */
          id: components["parameters"]["location_id"];
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": components["schemas"]["Review"][];
          };
        };
      };
    };
  };
  "/locations/{id}/review.json": {
    post: {
      parameters: {
        path: {
          /** Location ID. */
          id: components["parameters"]["location_id"];
        };
        query: {
          /** Author name. If not provided, defaults to the User's name if the user has not opted to add locations anonymously. */
          author?: components["parameters"]["author"];
          /** Review comment. */
          comment?: components["parameters"]["comment"];
          /**
           * Fruiting status.
           * - 0: Flowers.
           * - 1: Unripe fruit.
           * - 2: Ripe fruit.
           */
          fruiting?: components["parameters"]["fruiting"];
          /**
           * Quality rating.
           * - 0: Poor.
           * - 1: Fair.
           * - 2: Good.
           * - 3: Very good.
           * - 4: Excellent.
           */
          quality_rating?: components["parameters"]["quality_rating"];
          /**
           * Yield rating.
           * - 0: Poor.
           * - 1: Fair.
           * - 2: Good.
           * - 3: Very good.
           * - 4: Excellent.
           */
          yield_rating?: components["parameters"]["yield_rating"];
          /** Date visited in format YYYY-MM-DD. */
          observed_on?: components["parameters"]["observed_on"];
          /** Photo file basename. */
          photo_file_name?: components["parameters"]["photo_file_name"];
        };
      };
      responses: {
        /** Success */
        200: {
          content: {
            "application/json": {
              /** ID of Location. */
              location_id: number;
              /** ID of new Review. */
              observation_id: number;
              images?: components["schemas"]["PhotoPaths"];
            };
          };
        };
      };
      requestBody: {
        content: {
          "multipart/form-data": {
            photo_data?: string;
          };
        };
      };
    };
  };
}

export interface components {
  schemas: {
    /** Number of Locations in an area. */
    Cluster: {
      /** Longitude of the centerpoint of the Locations (in WGS84 decimal degrees). */
      lng: number;
      /** Latitude of the centerpoint of the Locations (in WGS84 decimal degrees). */
      lat: number;
      /** Number of Locations. Locations with multiple Types are counted as their number of Types. */
      count: number;
    };
    /** Location type. */
    BaseType: {
      /** Unique identifier. */
      id: number;
      /** Type ID of taxonomic parent. */
      parent_id: number | null;
      /** Whether pending admin review. */
      pending: boolean;
      /**
       * Scientific name.
       * - Genus (or higher rank): Prunus
       * - Subgenus: Prunus subg. Amygdalus
       * - Species: Prunus domestica
       * - Subspecies: Prunus domestica subsp. domestica, Prunus persica var. nucipersica, Brassica oleracea var. capitata f. rubra
       * - Hybrid: Prunus x eminens, Prunus cerasus x Prunus fruticosa
       * - Cultivar: Prunus persica 'George IV', Prunus domestica subsp. domestica 'Italian', Acer truncatum x platanoides 'Keithsform'
       */
      scientific_name: string | null;
      /** Scientific synonyms (comma-delimited). */
      scientific_synonyms: string | null;
      /**
       * Taxonomic rank
       * - 0: Polyphyletic
       * - 1: Kingdom
       * - 2: Phylum
       * - 3: Class
       * - 4: Order
       * - 5: Family
       * - 6: Genus
       * - 7: Multispecies
       * - 8: Species
       * - 9: Subspecies
       */
      taxonomic_rank: number | null;
      /** Categories as the decimal representation of a reverse binary mask of all possible categories [forager, freegan, honeybee, grafter]. For example, 1 ('0001' in binary) is reversed to '1000' and therefore [forager]. */
      category_mask: number | null;
      /** English name. */
      en_name: string;
      /** English synonyms (comma-delimited). */
      en_synonyms: string | null;
      /** German name. */
      de_name: string | null;
      /** Greek name. */
      el_name: string | null;
      /** Spanish name. */
      es_name: string | null;
      /** French name. */
      fr_name: string | null;
      /** Hebrew name. */
      he_name: string | null;
      /** Italian name. */
      it_name: string | null;
      /** Dutch name. */
      nl_name: string | null;
      /** Polish name. */
      pl_name: string | null;
      /** Brazilian Portuguese name. */
      pt_br_name: string | null;
      /** Taiwanese Chinese name (in traditional characters). */
      zh_tw_name: string | null;
      /** USDA symbol (TODO). */
      usda_symbol?: string | null;
      /** English Wikipedia (https://en.wikipedia.org) page. */
      wikipedia_url?: string | null;
      /** Eat the Weeds (https://www.eattheweeds.com) page. */
      eat_the_weeds_url?: string | null;
      /** Foraging Texas (https://www.foragingtexas.com) page. */
      foraging_texas_url?: string | null;
      /** Urban Mushrooms (https://urbanmushrooms.com) page. */
      urban_mushrooms_url?: string | null;
      /** Fruitipedia (http://www.fruitipedia.com) page. */
      fruitipedia_url?: string | null;
    };
    ListType: components["schemas"]["BaseType"] & {
      /** Common name in requested locale. */
      name: string | null;
      /** Number of Locations with Type in bounds at the requested zoom level. */
      count?: number;
    };
    SingleType: components["schemas"]["BaseType"] & {
      /** Date and time of creation in format YYYY-MM-DDThh:mm:ss.sssZ. */
      created_at: string;
      /** Date and time of last update in format YYYY-MM-DDThh:mm:ss.sssZ. */
      updated_at: string;
      /**
       * Edibility rating.
       * - -1: Not worth it (or toxic)
       * - 1: Include
       * - 2: Maybe include
       */
      edibility: (-1 | 1 | 2) | null;
      /** Arabic name. */
      ar_name: string | null;
      /** Slovak name. */
      sk_name: string | null;
      /** Slovene name. */
      sv_name: string | null;
      /** Turkish name. */
      tr_name: string | null;
      /** Admin notes. */
      notes: string | null;
    };
    /** Location. */
    BaseLocation: {
      /** Unique identifier */
      id: number;
      /** Longitude in WGS84 decimal degrees. */
      lng: number;
      /** Latitude in WGS84 decimal degrees. */
      lat: number;
      /** Type IDs. */
      type_ids: number[];
      /** Type common names in requested locale. */
      type_names: (string | null)[];
      /** Author name. */
      author: string | null;
      /** Whether suspected to be wrong in some way and requires verification. */
      unverified: boolean;
    };
    ListLocation: components["schemas"]["BaseLocation"] & {
      /** Photo basename. */
      photo_file_name?: string | null;
      photo?: components["schemas"]["PhotoPaths"];
      /** Distance in meters from provided centerpoint. */
      distance?: number;
    };
    /** Number of Location Types in an area. */
    TypeCount: {
      /** Type ID. */
      id: number;
      /** Number of Locations with that Type ID. */
      count: number;
    };
    SingleLocation: components["schemas"]["BaseLocation"] & {
      /**
       * Access level.
       * - 0: Location is on my property.
       * - 1: I have permission from the owner to add this Location.
       * - 2: Location is on public land.
       * - 3: Location is on private property but overhangs public property.
       * - 4: Location is on private property.
       */
      access: (0 | 1 | 2 | 3 | 4) | null;
      /** Address. Provided for imported locations whose coordinates had to be geocoded from an address. */
      address: string | null;
      /** City (reverse-geocoded from coordinates). */
      city: string | null;
      /** State (reverse-geocoded from coordinates). */
      state: string | null;
      /** County (reverse-geocoded from coordinates). */
      country: string | null;
      /** Description. */
      description: string | null;
      /** Whether imported from a municipal tree inventory. */
      muni: boolean;
      /** Number of reviews. */
      num_reviews: number;
      /** Review photos. */
      photos: components["schemas"]["Photo"][];
      /** First month in season (zero-based). */
      season_start: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
      /** Last month in season (zero-based). */
      season_stop: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
      /** Whether always in season (e.g. rosemary). Equivalent to `season_start=0` (January) and `season_stop=11` (December). */
      no_season: boolean;
      /** Date and time created. */
      created_at: string;
      /** Date and time last updated. */
      updated_at: string;
    };
    /** Observations of and opinions about a Location. */
    Review: {
      /** Review ID. */
      id: number;
      /** Location ID. */
      location_id: number;
      /** User ID. */
      user_id: number | null;
      /** Comment. */
      comment: string | null;
      /** Date and time visited in format YYYY-MM-DDThh:mm:ss.sssZ. */
      observed_on: string | null;
      /** Date and time created. */
      created_at: string;
      /** Date and time last updated. */
      updated_at: string;
      /** Fruiting status. */
      fruiting: (0 | 1 | 2) | null;
      /** Quality rating. */
      quality_rating: (0 | 1 | 2 | 3 | 4) | null;
      /** Yield rating. */
      yield_rating: (0 | 1 | 2 | 3 | 4) | null;
      /** Author name. */
      author: string | null;
      /** Original photo file name. */
      photo_file_name: string | null;
      /** Photo caption. */
      photo_caption: string | null;
      photo: components["schemas"]["PhotoPaths"];
    };
    /** Paths to different sizes of a Photo. */
    PhotoPaths: {
      /** Path to medium size file. */
      medium: string;
      /** Path to original file. */
      original: string;
      /** Path to thumbnail. */
      thumb: string;
    };
    /** Review photo. */
    Photo: {
      /** Unique identifier */
      id: number;
      /** Date and time of last update in format YYYY-MM-DDThh:mm:ss.sssZ. */
      photo_updated_at: string;
      /** Basename. */
      photo_file_name: string;
      photo: components["schemas"]["PhotoPaths"];
    };
    /** Error response. */
    Error: {
      /** Error message. */
      error: string;
    };
  };
  parameters: {
    /** Longitude of southwest corner in WGS84 decimal degrees. */
    swlng: number;
    /** Longitude of northeast corner in WGS84 decimal degrees. */
    nelng: number;
    /** Latitude of southwest corner in WGS84 decimal degrees. */
    swlat: number;
    /** Latitude of northeast corner in WGS84 decimal degrees. */
    nelat: number;
    /** Zoom level, where the world is divided into a 2<sup>zoom</sup> x 2<sup>zoom</sup> grid. */
    zoom: number;
    /** Whether to include Locations imported from municipal tree inventories. */
    muni: 0 | 1;
    /** Type categories to return. */
    c: ("forager" | "freegan" | "honeybee" | "grafter")[];
    /** Locale of common name labels to return. */
    locale:
      | "en"
      | "de"
      | "el"
      | "es"
      | "fr"
      | "he"
      | "it"
      | "nl"
      | "pl"
      | "pt_br"
      | "zh_tw";
    /** IDs of Types to include (or all if empty or missing). */
    t: number[];
    /** Location ID. */
    location_id: number;
    /** Longitude in WGS84 decimal degrees. */
    lng: number;
    /** Latitude in WGS84 decimal degrees. */
    lat: number;
    /** Type IDs. */
    type_ids: number[];
    /** Author name. If not provided, defaults to the User's name if the user has not opted to add locations anonymously. */
    author: string;
    /** Description. */
    description: string;
    /** First month in season (zero-based). */
    season_start: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
    /** Last month in season (zero-based). */
    season_stop: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
    /** Whether always in season (e.g. rosemary). Equivalent to `season_start=0` (January) and `season_stop=11` (December). */
    no_season: boolean;
    /** Whether needs verification. */
    unverified: boolean;
    /**
     * Access level.
     * - 0: Location is on my property.
     * - 1: I have permission from the owner to add this Location.
     * - 2: Location is on public land.
     * - 3: Location is on private property but overhangs public property.
     * - 4: Location is on private property.
     */
    access: 0 | 1 | 2 | 3 | 4;
    /** Review comment. */
    comment: string;
    /**
     * Fruiting status.
     * - 0: Flowers.
     * - 1: Unripe fruit.
     * - 2: Ripe fruit.
     */
    fruiting: 0 | 1 | 2;
    /**
     * Quality rating.
     * - 0: Poor.
     * - 1: Fair.
     * - 2: Good.
     * - 3: Very good.
     * - 4: Excellent.
     */
    quality_rating: 0 | 1 | 2 | 3 | 4;
    /**
     * Yield rating.
     * - 0: Poor.
     * - 1: Fair.
     * - 2: Good.
     * - 3: Very good.
     * - 4: Excellent.
     */
    yield_rating: 0 | 1 | 2 | 3 | 4;
    /** Date visited in format YYYY-MM-DD. */
    observed_on: string;
    /** Photo file basename. */
    photo_file_name: string;
  };
}

export interface operations {}
